/*
 * SoftPWM.c
 *
 * Created: 12/08/2019 01:59:14
 *  Author: Doug
 */ 

#include "Ibus.h"
#include "Doug.h"
#include "RC_PWM.h"

volatile uint8_t PwmChannel;      // Which channel we're currently on (0 to 9)

/* 
 * channels 1-10 - servo outputs
 * channels 11-14 - switch outputs
 * Servo outputs on Arduino ports D2-D11
 * switch outputs on Arduino ports A0-A3
 * 
 * Arduino port D12 is jumper input for servo test mode (insert bind jumper before power-on)
 * Arduino port D13 is LED L - indicates valid data being received from I-Bus feed
 *
 * L LED = RX signal
 * servo centre on power up (except channel 3 - throttle)
 * Throttle zero on power up (channel "THROTTLE" - normally 3)
 * failsafe - throttle zero 1/2 second after RX signal loss
 * 
 * Adding a jumper to Arduino pin D12 enables servo test mode, until first I-Bus packet
 * 
 * TIMER 1 is 8 prescaled 16 bit counter, clocked from system 16MHz clock
 * so 2000 counts per ms. Set compare register to 4000, to interrupt every 2ms
 * 
 * PCM timing for each channel generated by Timer1 compare reg A
 * Interrupt routine picks up PCM pulse change and multiplexes to 10 output pins
 * 10 channels at 2ms pulse width = 20ms overall repeat period (50) as per server spec
 * Timer 1 compare reg B triggers every 2ms (start of each servo pulse) to reset period
 * Timer 1 compare reg A triggers at end of current pulse, set by PWM channel value
 *
 * Optional "PWM_ESC" code uses timer 2 to output brushed ESC pulses to A4 and A5 pins
 * 
*/

#define CLEAR 0
#define SET 1
extern void PwmPort(uint8_t channel, uint8_t action);

uint8_t RC_MsClock;                 // Globally visible counter incremented every PWM interrupt - every 2ms
uint8_t AlarmFlag;                  // flags to turn on certain alarms

#ifdef PWM_ESC                      // if we've enabled brushed ESC functionality in header
uint8_t EscCount = 0;               // count of number of times timer 2 overflows
uint8_t EscDutyCycle;               // duty cycle set according to battery type
#endif // PWM_ESC

void RC_Pwm_Init(void)
{
    // Timer1 is 16bit, for full 1us PWM resolution)
    TCCR1B = 0b00000010;            // Set timer 1 prescaler to 8 (2MHz - 0.5uS)
    OCR1B = 4000;                   // set compare B reg to 4000 (2ms)
    TIMSK1 = 0b00000110;            // enable interrupt on compare A and B, for pulse end and start
                                    // ensure our port lines are low without changing others
    PORTD &= 0b00000011;            // we use upper 6 pins of port D (0 and 1 are UART)
    PORTB &= 0b11110000;            // we use lower 4 pins of port B (4 is test header input, 5 is LED)
    DDRD |= 0b11111100;             // set Port D pins 2-7 to OUTPUT (D2-D7)
    DDRB |= 0b00001111;             // set Port B pins 0-3 to OUTPUT (D8 - D11)
    DDRC |= 0b00001111;             // set Port C pins 0-3 to OUTPUT (A0 - A3)
    PwmChannel = 0;                 // set channel number to start of channels
    
#ifdef PWM_ESC                      // if we've enabled brushed ESC functionality in header
    TCCR2B = 0b00000011;            // set prescaler input to timer 0 / 64 - 250khz
                                    // any faster causes race condition giving max throttle at near min stick!
    OCR2A = 0;                      // set compare for ESC channel 1 to 0 (motor off)
    OCR2B = 0;                      // set compare for ESC channel 2 to 0 (motor off)
    TIMSK2 = 0b000000110;           // enable timer 0 interrupts for compare A, compare B, but NOT Overflow yet
                                    // overflow interrupt set once throttle has returned to zero
    PORTC &= 0b11001111;            // ensure pins C5 and C6 are output low
    DDRC |= 0b00110000;             // set pins C5 and C6 as outputs
    EscDutyCycle = 2;               // default ESC duty cycle to 2C battery type (1 in 3)
#endif // PWM_ESC   
}

ISR (TIMER1_COMPB_vect)             // timer 1 compare B has triggered - 2ms point
{                                   // this is PWM end of pulse period (not falling edge of pulse)
    TCNT1 = 0;                      // reset timer on compare match (counts every 2ms)
    PwmPort (PwmChannel, CLEAR);    // ensure current pulse is ended (should have been cleared by compare A interrupt)
    if (++PwmChannel >= 10 )        // we've reached the last PWM channel (11-14 are switch channels)
    {                               // this is the 20ms period
        ++RC_MsClock;               // increment global milisecond counter (counts every 20ms)
        PwmChannel = 0;             // so reset to start of channels
        cbi(PORTB,5);               // turn off rx data LED every 20ms (turned on every 7ms if data being received)
        if(++failsafe == 0)         // increment the failsafe counter (gets reset each valid RX packet)
                failsafe=0xFF;      // make sure failsafe doesn't roll over to zero
        if(failsafe > 25)           // failsafe counter incremented every 20ms
        {
            IbusChannels[THROTTLE] = 1000; // kill throttle if we haven't received RX data for 0.5 seconds
#ifdef DUAL_MOTOR
            IbusChannels[THROTTLE2] = 1000;// Dual motor setup
#endif // DUAL_MOTOR
            IBUS_ALARM_ON;          // alarm when in failsafe mode
        }
        // alarm beeper - check flags and pulse beeper according to alarm type
        BEEPEROFF;                  // turn off beeper completely to start with
        if(bit_is_set(AlarmFlag,THR_ALARM))  // test for various alarm types
        {
            if(bit_is_set(RC_MsClock,6) && bit_is_set(RC_MsClock,4)) // turn beeper on and off with bit in ms counter
                BEEPERON;           // toggle beeper sounder on with bit
            else
                BEEPEROFF;          // toggle off again
        }
        else if(bit_is_set(AlarmFlag,BATT_ALARM))
        {
            if(bit_is_set(RC_MsClock,5)) // turn beeper on and off with bit in ms counter
                BEEPERON;           // toggle beeper sounder on with bit
            else
                BEEPEROFF;          // toggle off again
        }
        else if(bit_is_set(AlarmFlag,IBUS_ALARM))
        {
            if(bit_is_set(RC_MsClock,6)) // turn beeper on and off with bit in ms counter
                BEEPERON;           // toggle beeper sounder on with bit
            else
                BEEPEROFF;          // toggle off again
        }
        else if(bit_is_set(AlarmFlag,SW_ALARM))
        {
            if(bit_is_set(RC_MsClock,4)) // turn beeper on and off with bit in ms counter
                BEEPERON;           // toggle beeper sounder on with bit
            else
                BEEPEROFF;          // toggle off again
        }
    }
    
    PwmPort(PwmChannel, SET);       // start pulse on next channel
    OCR1A = (IbusChannels[PwmChannel] * 2); // load compare reg A with pwm data for end of pulse
}                                           // *2 because timer is clocked at 0.5us 

ISR (TIMER1_COMPA_vect)             // timer 1 compare A has triggered - falling edge of pwm pulse
{
    PwmPort(PwmChannel, CLEAR);     // end pulse for current channel
}

void PwmPort(uint8_t channel, uint8_t action)
{
    if(action == SET)
    {
        if(channel < 6)             // First 6 channels are Arduino pins D2-D7
            sbi (PORTD,channel+2);  // next 4 channels are Arduino pins D8-D11
        else                        // D2-D7 are PORTD 2-7
            sbi (PORTB,channel-6);  // D8-D11 are PORTB 0-3
    }
    else                            // action = clear
    {
        if(channel < 6)
            cbi (PORTD,channel+2);
        else
            cbi (PORTB,channel-6);
    }
}

#ifdef PWM_ESC                      // code for ESC brushed motor drive

ISR (TIMER2_COMPA_vect)             // timer 0 compare A has triggered (ESC channel 1)
{
    cbi (PORTC,4);                  // clear esc channel 1 pin
}

ISR (TIMER2_COMPB_vect)             // timer 0 compare B has triggered (ESC channel 2)
{
    cbi (PORTC,5);                  // clear esc channel 1 pin
}

ISR (TIMER2_OVF_vect)               // timer 0 has overflowed (256 counts)
{
    if (++EscCount > EscDutyCycle) // EscCount is flag of ESC pulse duty cycle
    {
        EscCount = 0;               // counts from 0 to ESCDUTYCYCLE every timer overflow
        
        OCR2A = ((uint8_t)(IbusChannels[ESCLEFT] >> 3))-128;    // channel value is 16 bit 1000-2000, make 8 bit 0 - 128
        if ((int8_t)OCR2A <= 0)     // ensure we don't go negative (and turn motor full on!)
            OCR2A = 0;              // guarantee zero throttle turns motor off
        else
        {
            OCR2A = (OCR2A << 1)+1; // turn 1-127 into 2-255
            sbi(PORTC,4);           // set ESC pin high at start of pulse
        }

        OCR2B = ((uint8_t)(IbusChannels[ESCRIGHT] >> 3))-128;    // channel value is 16 bit 1000-2000, make 8 bit 0 - 128
        if ((int8_t)OCR2B <= 0)     // ensure we don't go negative (and turn motor full on!)
            OCR2B = 0;              // guarantee zero throttle turns motor off
        else
        {
            OCR2B = (OCR2B << 1)+1; // turn 1-127 into 2-255
            sbi(PORTC,5);           // set ESC pin high at start of pulse
        }
    }
}
#endif // PWM_ESC
